/**
 * Created by atif on 12/18/16.
 */
import React, { PropTypes } from 'react';
import moment from 'moment';
import TimeChartComponent from './TimeChart.component';

const propTypes = {
  data: PropTypes.object,
  tooltip: PropTypes.bool,
  startDate: PropTypes.string,
  endDate: PropTypes.string,
  label: PropTypes.string,
  showGraph: PropTypes.bool,
  linkTag: PropTypes.oneOfType([
    React.PropTypes.func,
    React.PropTypes.string
  ]),
  to: PropTypes.string,
  color: PropTypes.string
};

const defaultPropTypes = {
  startDate: '01/01/1970',
  endDate: '01/01/2099',
  tooltip: true,
  showGraph: true,
  label: 'Run Time',
  linkTag: 'a',
  to: '#'
};

let data = [];
let i;
let diffArr = [];
let prevStatus = true;
let roundedValue;
let sum;
let sumInMints;
let sumInHours;
let diff;
export default class TimeChartContainer extends React.Component {

  static renderTimeDiff(data, i) {
    diffArr = [];
    data.reverse(); // to get data in descending order
    for (i = 1; i < data.length; i++) {
      prevStatus = data[i - 1].data.standby; // get previous value of standby
      if (prevStatus === false) { // only get values for standby false as previous value
        const time1 = moment(new Date(data[i].time));
        const time2 = moment(new Date(data[i - 1].time));
        diff = time1.diff(time2, 'seconds'); // difference of two consecutive values in seconds
        if (diffArr.indexOf(diff) < 0) diffArr.push(diff); // push in array while avoiding duplicate entries
      }
    }
    sum = diffArr.reduce((a, b) => a + b); // get sum of values in array
    sumInHours = sum / 3600; // convert seconds to hours
    sum %= 3600;
    sumInMints = sum / 60; // convert seconds to minutes
    if (sumInMints > 0 && sumInMints < 1 && sumInHours < 1) {
      sumInMints = 1;
      roundedValue = 'Less Than 1 m';
    } else {
      roundedValue = `${Math.floor(sumInHours)} h` + ` ${Math.round(sumInMints)} m`;
    }
  }

  render() {
    const {
      color,
      tooltip,
      data: dbData,
      label,
      linkTag,
      to,
      showGraph,
      ...rest
    } = this.props;
    let lastReading = 'No data found';

    if (this.props.data === undefined || this.props.data.loading) {
      lastReading = 'Loading data';
    }

    try {

      // let dataFromQuery = dbData.node.events.edges;
      let dataFromQuery = dbData.Event.EventFind.edges;
      if (dataFromQuery.length === 0) {
        data = [];
      } else {
        dataFromQuery = dataFromQuery.map(item => item.node);
        {
          TimeChartContainer.renderTimeDiff(dataFromQuery, i);
        }
        dataFromQuery.forEach((item, i) => {
          if (item.data && item.data.standby !== undefined) {
            data.push({
              time: new Date(item.time),
              standby: item.data.standby ? false : true
            });
          }
        });
        if (data.length > 0) {
          data.sort((a, b) => (a.time > b.time) ? 1 : ((b.time > a.time) ? -1 : 0));
          // lastReading = `${data[data.length - 1].standby ? 'On' : 'Off'}`;
          lastReading = roundedValue;
        }
      }

    } catch (error) {
      // console.info('Time Chart no data found');
    }
    // lastReading = roundedValue;
    if (showGraph) {
      return (
        <TimeChartComponent
          data={data}
          x="time"
          y={datum => (datum.standby)}
          color={this.props.color}
          label={label}
          value={lastReading}
          tooltip={this.props.tooltip}
          tooltipBooleanTrueLabel="Off"
          tooltipBooleanFalseLabel="On"
          linkTag={linkTag}
          to={to}
          {...rest}
        />

      );
    }
    return (
      <TimeChartComponent
        color={color}
        label={label}
        value={lastReading}
        tooltip={tooltip}
        linkTag={linkTag}
        to={to}
        {...rest}
      />
    );
  }

}

TimeChartContainer.propTypes = propTypes;
TimeChartContainer.defaultProps = defaultPropTypes;
