import React, { PropTypes } from 'react';
import EnergySavingChartComponent from './EnergySavingChart.component';

const propTypes = {
  data: PropTypes.object,
  tooltip: PropTypes.bool,
  startDate: PropTypes.string,
  endDate: PropTypes.string,
  label: PropTypes.string,
  showGraph: PropTypes.bool,
  linkTag: PropTypes.oneOfType([
    React.PropTypes.func,
    React.PropTypes.string
  ]),
  to: PropTypes.string,
  color: PropTypes.string
};

const defaultPropTypes = {
  startDate: '01/01/1970',
  endDate: '01/01/2099',
  tooltip: true,
  showGraph: true,
  label: 'Average Energy Saving',
  linkTag: 'a',
  to: '#'
};

const currentThreshold = 0.6;
let currentLatest;
export default class EnergySavingChartContainer extends React.Component {

  render() {
    const {
      tooltip,
      data: dbData,
      label,
      linkTag,
      to,
      color,
      showGraph,
      ...rest
    } = this.props;
    let data = [];
    let lastReading = 'No data found';
    if (this.props.data === undefined || this.props.data.loading) {
      lastReading = 'Loading data';
    }

    try {
      let dataFromQuery = dbData.Event.EventFind.edges;
      const maxMetaValue = 9.7;
      // const maxMetaValue = dbData.node.devices.edges[0].node.specification.capabilityItems.edges[0].node.options.max ?
      //   dbData.node.devices.edges[0].node.specification.capabilityItems.edges[0].node.options.max :
      //   dbData.node.devices.edges[0].node.specification.capabilityItems.edges[0].node.capability.defaultOptions.max;
      dataFromQuery = dataFromQuery.map(item => item.node);
      dataFromQuery.forEach((item) => {
        if (item.data && item.data.current !== undefined) {
          currentLatest = item.data.current;
          let effPercent = ((maxMetaValue - currentLatest) / maxMetaValue) * 100;
          if (effPercent < 0) {
            effPercent = 0;
          } else if (effPercent > 100) {
            effPercent = 100;
          }
          data.push({
            time: new Date(item.time),
            current: effPercent
          });
        }
      });
      data = data.filter(el =>
        el.current >= currentThreshold
      );
      if (data.length > 0) {
        data.sort((a, b) => (a.time > b.time) ? 1 : ((b.time > a.time) ? -1 : 0));

        // Sum of data
        const sum = data.reduce((a, b) => a + b.current, 0);
        const average = sum / data.length;
        lastReading = `${average.toFixed(2)} %`;
      }
    } catch (error) {
      // console.info('Energy Saving Chart: no data found');
    }
    if (showGraph) {
      return (
        <EnergySavingChartComponent
          data={data}
          x="time"
          y={datum => (datum.current)}
          color={color}
          label={label}
          value={lastReading}
          tooltip={tooltip}
          linkTag={linkTag}
          to={to}
          {...rest}
        />
      );
    }
    return (
      <EnergySavingChartComponent
        color={color}
        label={label}
        value={lastReading}
        tooltip={tooltip}
        linkTag={linkTag}
        to={to}
        {...rest}
      />
    );
  }
}

EnergySavingChartContainer.propTypes = propTypes;
EnergySavingChartContainer.defaultProps = defaultPropTypes;
